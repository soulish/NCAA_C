This is my NCAA basketball analysis code.  It was originally written in
Ruby, however I have converted it into C++ for this project.  There are 
still a few Ruby files around to easily display some of the graphs and
histograms made by some of the programs, but all of the actual work is done
in C++.

I will be writing up a complete document on the theory and formulas used
in this project, which will be uploaded into this folder as a pdf, but
for now I will simply try to explain what all of the files are and their
purposes, and also show the order in which to run the program files which
exist in this main directory.

The basic idea behind this project is that I want to have a fairly simple
equation to quickly tell me, for a game involving Team A and Team B, at
a set location (home for A, home for B, or at a neutral site), on a given
day, how likely team A is to win, and how likely team B is to win.  And I
want this equation to rely solely on values derived from very basic team
statistics.  There is no information about the players involved, what 
conference they are in, who the coach is, etc.  Only information that can
be gleaned from the box scores of games played prior to the date in 
question will be used.

In order to make my predictions in a given year, I rely on averages, ratios,
and other constants that have been calculated using the 5 seasons prior.  Thus
to make a prediction for a game in the 2016 season (note: I list seasons
by the year in which they end, so the 2016 season is shorthand for the
2015-2016 season), I will need the statistics for the 2011, 2012, 2013, 2014
and 2015 seasons.  

I have gathered the box scores for every single Division-I
college basketball game played since the 2001 season, and they reside in the
teams/YEAR/ directory, where YEAR is the year in question, i.e. any number
between 2001 and 2016.  In each year directory, there is a single file for
every team labelled teams.YEAR_team_name.games.d (e.g. 
teams.2015_north_carolina.games.d), which contains the box score information
for every game they played that season, including the opponent's name, the
date, the location, whether they won or lost, how many points they scored,
how many field goals they made and attempted, etc, as well as those same
stats for their opponents.  The data is stored in comma-separated lists,
with each game on a different line.  Because of the sheer number of files
required, and their unimportance for understanding the rest of the code,
I have only uploaded a single example file to github, but in reality there
are nearly 350 files per year.

There is a constants directory, which contains many files that will be 
created throughout the course of running the program files, but initially
it would be empty.

There is also a tournamentInfo directory, which contains information about
the NCAA tournament for every year since 2001.  Those files will not be 
needed until the very end of the process.

Lastly, there is a helpers directory, which contains very small bits of
helpful code that will be useful throughout the project.  One is called
doubleFormatter.h, which contains a single function, doubleFormatter, which
takes a double and returns a string with that double formatted to have 
a set number of digits after the decimal point.  The other is called
vectorMinMax.h, which has a function to return the index of the minimum
value of a vector.


################
The Main Classes
################

Now, for the src/ directory.  This directory contains all of the class
definitions. There are 9 main classes, and 9 singleton classes to contain
the constants generated by and needed for the programs.  

The Team class is the main class that the user has access to.  It has
hashes to contain the TeamGames (explained below), TeamAverages (explained
below), and TeamWAverages (explained below), each indexed by the date.  It
contains methods used to add an individual TeamGame, TeamAverage or 
TeamWAverage, as well as to add all of the games in team game file at once.  It
also has methods to get those hashes, as well as the TeamGame, TeamAverage,
or TeamWAverage on a given date.  There is a static hash used to store
the pointer to the team by the team name.  It also contains a method
to calculate the weighted average (explained below) on a given date.

There is a file called readTeams.h that provides a method to read all of 
the files in a given directory (one of the teams/YEAR/ directories) and add
in all of the games, averages, or waverage files in that directory.  This is
used to add all of the teams in a given year in at once.  This is the main
way to read in the game, average, or waverage information in the programs,
except for a few programs where only one or two teams' information is read
in at once.

The Pct class is used to store variables that have two main bits of
information, the number of attempts, and the number of makes, and from them
calculate a percentage.  A Pct can be constructed either with two integers,
two doubles (necessary when considering averages),  or by specifying the
percentage as well as the number of makes and attempts.  The class provides
methods for getting the number of makes, or attempts, the percentage, and
also to calculate the variance, standard deviation, and a few other 
statistical values.  Almost all of the statistics used in the TeamGame,
TeamAverage, and TeamWAverage classes are stored in Pct variables.

The Pcts class is a fancy container to hold Pct pointers and to make 
calcuations with them.  The average percentage over all of the Pct pointers
can be calculated with p_bar(), as can the weighted average, standard 
deviation, and weighted standard deviation.

The Game class is a superclass containing some basic information about
games.  In this project there probably is not a need for this class to be
separate from TeamGame, but as this same code is also used for the NBA 
project, which contains a PlayerGame class, I have decided to leave it this
way.  The properties of a game are the name, opponent, location, date, 
number of points scored, number of personal fouls, and then Pct properties
for offensive field goals, offensive two-point field goals, offensive
three-point field goals, offensive free-throws, offensive effective field
goal percentage, offensive true-shooting percentage, and offensive
free-throw-made rate.  There are no methods other than standard getters 
in this class.

The TeamGame class inherits from the Game class, and adds on variables for
game number, whether the game was a win or loss, the number of offensive
possessions, the spread of the game, and then Pct variables for
offensive offensive rebounding percentage (note, the double offensive was
intentional, offensive rebounding percentage is a stat, and the initial
offensive is there to indicate this is what the team in question got,
defensive ORB would be what the opposing team got), offensive defensive
rebounding percentage, offensive total rebounding rate, offensive
assist, steal, block, and turnover percentages.  Then all of the stats
stored for the offense are also stored for the defense (both the Game
and TeamGame stats).  There are standard getter functions for each of the
variables, but there are also two functions, getPct and getValue, which
return values based on an input string.

The TeamAverage class is used both for averages and for weighted averages,
as the TeamWAverage class is a subclass, adding only a few extra variables.
It contains fields for team name, date, and the number of games played by
the team up to the date of the instance.  There are also fields for the
number of offensive points and defensive points points scored to this point
of the season.  The rest of the variables are Pct variables.  The main ones
of which are offensive offensive rebounds, offensive effective field goals,
offensive free-throw-made rate, and offensive turnover rate, as well as 
their defensive countepoints.There are standard getter functions for each of 
the variables, but there are also two functions, getPct and getValue, which
return values based on an input string.

The TeamWAverage class is a subclass of TeamAverage.  It adds variables
for RPI, SRS, original SRS (useful because SRS is calculated through
and iterative process), and strength of schedule, SOS.

The two remaining classes are for used for simulating the NCAA tournament.
TournamentRegion contains holds information about the
starting state of the tournament (read in from the files in the 
tournamentInfo directory), and then contains methods for simulating each
of the first four rounds plus the play-in games (if necessary).  There are
also methods for calculating the likelihood of each team in the region
reaching each of the rounds in the tournament, as well as winning the
entire region.  

The Tournament class has a container to hold 4 TournamentRegion pointers,
which it then fills up using the method readTournamentInfo.  It then
has methods to play out the entire tournament, or calculate the likelihood
of each team in the tournament reaching each of the rounds in the tournament,
as well as winning the entire tournament.

################
The Constant Classes
################

These classes are used to store constants needed in the programs.  Each of
the classes are singleton classes with few methods (generally only a way
to read in the information, and a way to access that info).  The exception
to that are the ConstantGameFunction and ConstantWAverageFunctions classes,
which contain methods to evaulate the functions stored within them, both
given a pair of teams and the location of the game, or given only one team
where we simulate a game against a completely average opponent.

The classes are:

ConstantSeasonInfo - containing the important dates in the season
ConstantTeam5YearAverages - containing the team averages for each stat
			    over the previous 5 seasons, for each
			    season from 2003-2016.
ConstantTeamNeutralRatios - containing the neutral ratios for each stat
			    at each location (home, away, neutral) over
			    the previous 5 seasons, for each season
			    from 2003-2016.
ConstantTeamPointDifferentials - containing the average point differentials
			    over the previous 5 seasons, for each
			    season from 2003-2016.
ConstantTeamWinRatios - containing the win ratios
			over the previous 5 seasons, for each
			season from 2003-2016.
ConstantSRSadditions - containing the SRS additions determined from the
		       previous 5 seasons, for each season from 2005-2016.
ConstantStandardDeviations - containing the standard deviations for the
			     TeamWAverages for each of the eight useful
			     stats over the previous 5 seasons, for each 
			     season from 2005-2016.
ConstantWAverageFunctions - containing the functions used to determine the
			    predicted value of an offensive stat given
			    an offensive weighted average and defensive
			    weighted average.  These were calculated using
			    the previous 5 years stats for every season
			    from 2005-2016.
ConstantGameFunction - containing the functions used to predict a winner
		       in a game.  These were calculated using the previous
		       5 years stats for every season from 2005-2016.


################
The Programs
################

generateAverages
generateWeightedAverages.cpp
calculateSRS.cpp
generateSRSadditions.cpp
generateWAverageFunctions.cpp
generateStandardDeviations.cpp
generateWeights.cpp
generateWeightsFixedSRS.cpp
generateGameFunctionHistograms.cpp
checkGamePredictions.cpp
tournamentSimulation.cpp

showTeamStats.cpp
showTeamStats.rb
showTournamentMatchup.cpp
showTournamentMatchup.rb
showWAverageFns.rb
confirmStandardDeviations.cpp
rankTeamsByGameScore.cpp
